//remind
레지스터 : 주요 레지스터 네이밍, 설명 확인
> 지정된 역할 외에 다른 용도로 사용되기도 함.
> EBP, ESP, EIP

// 어셈블리어 및 디버거 
어셈블리어
conditional jmp > if문
dbg.exe : 어셈블리어 디버깅
> 컴파일러에 의해 추가된 코드는 분석할 필요 X.
>> 강사님이 만들어놓은 코드를 찾아서 F2 로 breakpoint 설정 및 F9로 이동.
> 해당 코드 안에 navigation message가 있음.
> 우클릭\다음을찾기\현재구역\문자열참조
> 더블클릭으로 해당 문자열 사용 위치로 이동
? 주석 값이라고 하신게 함수의 내용인가 함수 설명인가
A. 주석이 아니라 해당 주소에 있는 변수의 값을 해석하여 표시해준 것.
> push : 스택에 값을 넣음.

401194 : printf("[navigation]")
> Enter or "-" : 디버거의 진행에 상관없이 함수 내용 확인하기."
> Shift+";" : 다음에 레이블 추가(comment)
> EBP, ESP, EIP 는 건드리지 말 것
> 16진수
  0000 > 0
  1111 > F
> Space : Opcode 및 Operand 수정

스택(오른쪽아래)
> push : stack에 ESP에 값을 넣고, ESP-4
> DC : 현재 스택 주소(ESP) 기준 주소값 보여줌
> dword > double word(4byte) , ptr(pointer), ds(data source) 
>> 해당 주소의 값을 이용함(포인터)
> 인텔은 little Endian 설정되어 있음(뒤에서부터 읽기)
> pop : stack에서 ESP에 있는 값을 불러오고, stack에서 삭제

산술 연산 : add, mov, sub, inc, dec 
> inc : increse(1)
> dec : decrese(1)

비트 연산 : not, ror, rol
<참고> 원하는 위치에 "우클릭"하고 "여기에 원점 설정" 설정 후 "다시 시작" 하면 됨.
> 실무에서는 해당 기능 사용시 프로그램이 꼬일 수 있음.
> 실무에서는 실행되지 않는 코드에 강제로 접근하기 위해 사용</참고>
> ror : 입력값만큼 오른쪽(right) 비트회전
> rol : 입력값만큼 왼쪽(left) 비트회전
<참고> Ctrl + G : 원하는 주소로 이동</참고>

제어 연산 : cmp, je, jne
> cmp : 비교해서 같으면 ZF(Zero Flag)가 1, 다르면 0이 됨. > 해당 값을 가지고 je, jne가 동작함.
> je,jne : 화살표가 빨간색이면 해당 명령으로 점프한다, 파란색이면 점프 안 한다.
>> 디버거에서 "어셈블리 코드 변조(Space), 레지스터 값 변조(더블클릭), ZF 변조(더블클릭)"를 통해 다음 동작 조작 가능
? 지역변수 선언, for문의 지역변수 초기화 등은 캡처에 잘려있는건가요, 아니면 어셈블리에 없는건가요
A. 해당 코드는 잘려있음. 함수 프롤로그에 포함되어 있는데 이해의 어려움 때문에 생략되었음.

반복문(for)
> 지역변수는 stack에 저장됨. EBP 기준으로 

비교문(if)
jle :  

스택(Stack)
> 함수별로 stack frame이 할당되고, 해당 stack에는 지역변수,함수복귀주소,함수호출인자,베이스포인터 등이 들어있음.
> 함수 프롤로그에 stack frame 할당이 포함되어 있음. 
> EBP, ESP는 건드리면 안됨.

힙(Heap)

// 실습 : dbg1
참조 작성 : call문-Enter-Shift+";"-작성-"-"

과제1. "훌륭하게 변조했군요!" 를 Console에 띄우기
> "문자열 참조"통해 해당 문자열 위치 확인
> "jne"로 해당 문자열 출력을 건너뜀을 확인
> ZF 변조, Opcode 혹은 Operand 변조 등을 통해 해당 코드(문자열을 스택에, 스택을 출력)
> 방법1. ZF 변조
> 방법2. Opcode 및 Operand 변조
> 방법3. 해당 변수 값 변조(HEX 값을 원하는 포인터로 변조)
> 방법4. 

과제1. 
> ZF값을 더블클릭으로 변경
과제2. 
or eax, 0xFFFFFFFF >> and eax, 0x00000000
> 비교함수의 값을 0에서 "FFFFFFFF"로 변경
> 함수 내에서 push ebp ~~ pop ebp를 통해서 복귀주소 저장 및 esp를 ebp로 사용(해당 함수의 stack frame)
>> 함수 내 지역변수는 "EBP-~~", 매개변수 값은 "EBP+~~" 으로 스택을 사용함.

과제3. 
> 스택에서 값 변경
과제4. 반복문 탈출
> 스택에서 값 변경 : 포인터가 가르키는 값(기존 "0")을 비교값 "3E8"로 변경
<박스>
Sleep 
push 186A0	// =100000 => 10만 msec => 약 16.67분
call dward ptr ds:[<&Sleep>]
</박스>

> (다른해) Sleep 인자값(push)을 0으로 설정하면 바로 나옴

(참고)breakpoint를 if문 안이나 jump로 건너뛰는 곳에 넣는 경우(실제로 많이 일어남)
(참고)stack 주소창에 "ebp"라고 입력하면 알아서 찾아가네

? 스택에 저장된 값을 보고 스택 주소인지 코드 주소인지 값인지 판별하는 주체는 (어셈블리 파일 내 헤더, 디버거)
A. cpu는 구분하지 않는다. 분석자(사람)나 디버거가 문맥, 힌트 등으로 임의로 판단하는 것임.

//crackme
어셈블리편집 금지
생성형AI 금지

1. crackme2 : find_number
(참고)scanf 함수 포함되어 있음.

2. crackme2 : find_input_key
ebp-58 : 자릿수

asdfasdfasdfasdfasdfasdfasdfasdfasdfasd
39
Hello World! This Is Simple Reverse Engineering
47

반복문 eax == 28에 탈출
60 72 63 65

EHMC^XNTQ^JDX^SGHR^HR^RHLOKD^QDUDQRHMF
DGLB]WMSP]ICW]RFGQ]GQ]QGKNJC]PCTCPQGLE

FIND_XOUR_KEY_THIS_IS_SIMPLECREVERSING
FIND_YOUR_KEY_THIS_IS_SIMPLE_REVERSING

x32dbg를 이용한 어셈블리 디버깅 이론 및 실습

